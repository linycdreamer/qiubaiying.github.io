---
layout:     post
title:      ROS基础教程
subtitle:   ROS学习之路
date:       2018-09-23
author:     linyicheng
header-img: img/air-84675_1280.jpg
catalog: true
tags:
    - ROS
---
# 前言
学习ros最好的教程便是维基百科，但是要注意一点便是中文的维基百科比较的旧特别容易出问题。还是推荐使用英文的维基百科，英文不好的同学可以用谷歌翻译（虽然翻译的水平很烂，但是可以中英文对照着看），推荐一个好办法就是看中文的维基但是命令都用英文版的维基上面的。当然对英文很反感的同学也可以看这里创客制造翻译的教程
闲话不多说，我的环境是Ubuntu14.04 ros和indigo。安装教程很多，也比较简单就不详细说明。
*****
### 创建ROS包   
   1. 创建catkin工作空间
   ```
   source /opt/ros/indigo/setup.bash
   mkdir -p ~/mudu/src
   cd ~/mudu/
   catkin_make
   source devel/setup.bash 
   (```
   这样我们就新建了一个catkin工作空间
   2. 创建catkin包
   ```
   cd src/
   catkin_create_pkg robot std_msgs rospy roscpp
   cd ..
   catkin_make
   ```
   这样我们就成功创建了一个包含std_msgs rospy roscpp的catkin包，接下来我们验证一下是否成功
   输入
   `rospack depends1 robot`
   如果出现，说明创建成功了。你可以继续下面的操作，如果不行只能重新来一次，可能某一步出错了，也可以参考维基百科
   ```
   ~/mudu$ rospack depends1 robot
   roscpp
   rospy
   std_msgs
   ```
### 编译ros程序包
   这一步十分便捷，只需要cd到最外层的目录下，然后
   `catkin_make`
   输入命令ls出现三个文件夹，如果出错请确定当前已经source过。
   ```
   ls
   build  devel  src
   ```
### 创建msg和srv
   1. 创建msg
   进入robot路径
   `roscd robot`
   创建一个Num.msg文件
   ```
   mkdir msg
   echo "int64 num" > msg/Num.msg
   ```
   更改package.xml，这个文件就在当前目录下可以ls看到
   取消如下两行
   ```
   <build_depend>message_generation</build_depend>
   <!-- Use build_export_depend for packages you need in order to build against this package: -->
   <!--   <build_export_depend>message_generation</build_export_depend> -->
   <!-- Use buildtool_depend for build tool packages: -->
   <!--   <buildtool_depend>catkin</buildtool_depend> -->
   <!-- Use exec_depend for packages you need at runtime: -->
   <exec_depend>message_runtime</exec_depend> 
   find_package(catkin REQUIRED COMPONENTS#在cmakelist下更改成如下形式
   roscpp
   rospy
   std_msgs
   message_generation
   )
   ##取消注释并改成下面的形式
   add_message_files(
   FILES
   Message1.msg
   Message2.msg
   )
   add_message_files(
   FILES
   Num.msg
   )
   ##取消下面的注释
   generate_messages(
   DEPENDENCIES
   std_msgs
   )
   ```
   现在可以运行一下，观察是否正确
   `rosmsg show Num`
   出现下面的结果说明正确
   ```
   ~/robochengzi/src/robot$ rosmsg show Num
   [robot/Num]:
   int64 num
   ```
   2. 新建一个srv
   ```
   roscd beginner_tutorials
   mkdir srv 
   ```
   这次我们使用复制的方式
   `roscp rospy_tutorials AddTwoInts.srv srv/AddTwoInts.srv`
   同样我们要更改Cmakelist文件
   找到如下代码
   ```
   # add_service_files(
   #   FILES
   #   Service1.srv
   #   Service2.srv
   # )
   ```
   改成
   ```
   ## Generate services in the 'srv' folder
   add_service_files(
   FILES
   AddTwoInts.srv
   )
   ```
   下面检验一下我们的srv文件
   输入
   `rossrv show robot/AddTwoInts`
   如果看见
   ```
   ~/robochengzi/src/robot$ rossrv show robot/AddTwoInts 
   int64 a
   int64 b
   ---
   int64 sum
   ```
   说明正常
###编写简单的Publisher和Subscriber
   1. 首先，进入目录新建一个src文件夹（如果没有source先source一下）
   `mkdir -p src`
   在src文件夹内新建一个文件talker.cpp
   ```
   cd src
   touch talker.cpp
   ```
   在talker.cpp里面写入下面的内容
```
#include "ros/ros.h"//包括ROS中常用的公共部分的定义
#include "std_msgs/String.h"//消息包的头文件
#include "sstream"
int main(int argc,char **argv)
{
//ROS初始化 将节点命名为talker
    ros::init(argc,argv,"talker");
//创建一个句柄到进程的节点，第一个表示初始化，最后一个NodeHandle会将所有的资源清除
    ros::NodeHandle n;
//创建一个子类PUblish类型 叫chatter_pub 传送的信息为string类型，最多接受1000个
    ros::Publisher chatter_pub=n.advertise<std_msgs::String>("chatter",1000);
//以10HZ来运行
    ros::Rate loop_rate(10);
    int count=0;
//当按下ctrl c时，rose：：ok()会返回false
    while(ros::ok())
    {
//定义了一个要发布的msg
        std_msgs::String msg;
//定义一个要在终端打印出来的ss
        std::stringstream ss;
//给ss赋值
        ss<<"hello world"<<count;
//给msg赋值，这里msg只有sting这一种类型
        msg.data=ss.str();
//ROS_INFO相当于printf
        ROS_INFO("%s",msg.data.c_str());
//把消息广播给任何人
        chatter_pub.publish(msg);
//回调时使用
        ros::spinOnce();
//在10hz以外的其他时间节点都是处于休眠状态的
        loop_rate.sleep();
        ++count;

    }
    return 0;
}
```
   2. 编写Subscriber 
   和之前一样在src中新建一个src/listener.cpp文件
   `touch listener.cpp`
   同样我们在listener.cpp里面写入下面的代码
   ```
#include "ros/ros.h"
#include "std_msgs/Sring.h"
//回调函数，在接收到消息后调用
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
    ROS_INFO("I heard: [%s]",msg->data.c_str())
}

int main(int argc,char **argv)
{
    ros::init(argc,argv,"listener");
    ros::NodeHandle n;
//在接收到消息时调用chatterCallback函数
    ros::Subscriber sub =n.subscribe("chatter",1000,chatterCallback);
//没有接收到消息时，一直循环
    ros::spin();
    return 0;
}   
   ```
   现在万事具备，只要编译一下就好  
   ```
   cd ~/mudu/
   catkin_make
   ```
### 执行Publisher和Subscriber
   好,激动人心的一步到了，之前做的那么多终于要拿出来运行了
   首先运行ros（这一步不成功是安装的问题，问题有很多种先百度解决）
   `roscore`
   打开新的终端
   首先source一下然后运行程序
   ```
   cd ~/mudu/
   source ./devel/setup.bash
   rosrun robot talker
   ```
   运行成功的结果是这样的
   ```
[ INFO] [1517237329.554897985]: hello world 24
[ INFO] [1517237329.654934314]: hello world 25
[ INFO] [1517237329.754879845]: hello world 26
[ INFO] [1517237329.854875335]: hello world 27
[ INFO] [1517237329.954874894]: hello world 28
[ INFO] [1517237330.055077860]: hello world 29
[ INFO] [1517237330.154935016]: hello world 30
[ INFO] [1517237330.254920792]: hello world 31
[ INFO] [1517237330.354878216]: hello world 32
[ INFO] [1517237330.454899610]: hello world 33
[ INFO] [1517237330.554937169]: hello world 34   
   ```
   运行到这都没有问题，说明已经基本成功了后面一个也是一样运行
   同样新打开一个终端，source一下然后运行程序就好
   ```
   cd ~/mudu/
   source ./devel/setup.bash
   rosrun robot listener
   ```
   运行成功的结果如下
   ```
[ INFO] [1517237548.156052887]: I heard: [hello world 2210]
[ INFO] [1517237548.255744517]: I heard: [hello world 2211]
[ INFO] [1517237548.355945225]: I heard: [hello world 2212]
[ INFO] [1517237548.455125980]: I heard: [hello world 2213]
[ INFO] [1517237548.555806475]: I heard: [hello world 2214]
[ INFO] [1517237548.655804706]: I heard: [hello world 2215]
   ```
### 编写简单的Service和Client
   和上面一样我们在src文件里面新建两个文件 add_two_ints_server.cpp 和add_two_ints_client.cpp
   ```
   cd src
   touch add_two_ints_server.cpp
   touch add_two_ints_client.cpp
   ```
   分别在两个文件里面粘贴下面的代码
   add_two_ints_server.cpp    
   ```
#include "ros/ros.h"
//之前创建的srv文件生成的头文件
#include "beginner_tutorials/AddTwoInts.h"
//回调函数 接收srv文件中定义的请求和响应类型，并返回一个bool值
bool add(beginner_tutorials::AddTwoInts::Request &req,
         beginner_tutorials::AddTwoInts::Response &res)
{
    res.sum=req.a+req.b;
    ROS_INFO("request:x%ld,y=%ld",(long int)req.a,(long int)req.b);
    ROS_INFO("sending back respond:[%ld]",(long int)res.sum);
    return true;
}
int main(int argc,char ** argv)
{
    ros::init(argc,argv,"add_two_ints_server");
    ros::NodeHandle n;

    ros::Serviceserver service=n.advertiseService("add_two_ints",add);
    ROS_INFO("Ready to add two ints.");
    ros::spin();

    return 0;
}
   ```
   add_two_ints_client.cpp   
   ```
#include "ros/ros.h"
#include "beginner_tutorials/AddTwoInts.h"
#include <cstdlib>
int main(int argc,char **argv)
{
    ros::init(argc,argv,"add_two_ints_client");
    if(argc!=3)
    {
        ROS_INFO("usage:add_two_ints_client X Y");
        return 1;
    }
    ros::NodeHandle n;
//创建一个客户端 该对象用于以后的回调
    ros::ServiceClient client=n.serviceClient<beginner_tutorials::AddTwoInts>
            ("add_two_ints");
    beginner_tutorials::AddTwoInts srv;
    srv.request.a=atoll(argv[1]);
    srv.request.b=atoll(argv[2]);
    if(client.call(srv))
    {
        ROS_INFO("Sum:%ld",(long int)srv.response.sum);
    }
    else
    {
        ROS_ERROR("Failed to call service add_two_ints");
        return 1;
    }
    return 0;
}
   ```
   最后，我们在Cmakelist里面加上这两个文件
   在文件的最下面加上
   ```
add_executable(add_two_ints_server src/add_two_ints_server.cpp)
target_link_libraries(add_two_ints_server ${catkin_LIBRARIES})
add_dependencies(add_two_ints_server beginner_tutorials_gencpp)

add_executable(add_two_ints_client src/add_two_ints_client.cpp)
target_link_libraries(add_two_ints_client ${catkin_LIBRARIES})
add_dependencies(add_two_ints_client beginner_tutorials_gencpp)
   ```
   编译一下
   ` catkin_make`
### 执行Service和Client
   首先，运行roscore
   `roscore`
   然后启动两个节点
   `rosrun robot add_two_ints_serve`
   `rosrun robot add_two_ints_client 2 4`
   这两行命令必须要在两个新的终端内执行，在每个新终端都必须加上source 命令，
   `source ./devel/setup.bash`
   最后，如果它如愿的返回答案为6的话，那么恭喜你完成了基础部分的教学。
   其实，最好的教程是官网的维基，我们的博客只能算是过来人的一种经验，后续我们继续学习move_base 包，我们一起从零开始做一个小激光slam机器人出来。

   